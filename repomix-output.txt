This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-04-21T00:05:26.652Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
components/
  auth/
    GoogleSignInButton.vue
  dashboard/
    Dashboard.vue
    UnparsedList.vue
  ui/
    ErrorBanner.vue
  LogoutButton.vue
composables/
  useDashboard.ts
middleware/
  auth.global.ts
pages/
  auth/
    callback.vue
  index.vue
  login.vue
  settings.vue
server/
  tsconfig.json
supabase/
  .temp/
    cli-latest
    gotrue-version
    pooler-url
    postgres-version
    project-ref
    rest-version
    storage-version
  functions/
    auth-copy-provider-token/
      deno.json
      index.ts
    sync-gmail/
      .npmrc
      deno.json
      index.ts
  config.toml
types/
  gmailSync.ts
utils/
  supabaseFunctions.ts
app.vue
eslint.config.mjs
nuxt.config.ts
package.json
repomix.config.json
tsconfig.json

================================================================
Files
================================================================

================
File: components/auth/GoogleSignInButton.vue
================
<template>
  <button
    @click="$emit('click')"
    class="google-signin-button"
  >
    <!-- Placeholder for Google Icon -->
    <span class="google-icon">G</span>
    Sign in with Google
  </button>
</template>

<script setup>
defineEmits(['click'])
</script>

<style scoped>
.google-signin-button {
  display: inline-flex;
  align-items: center;
  justify-content: center;
  padding: var(--space-sm) var(--space-lg);
  border: 1px solid transparent;
  font-size: var(--font-sm);
  font-weight: 500;
  border-radius: var(--border-radius-md);
  box-shadow: var(--shadow-sm);
  color: var(--color-primary-button-text);
  background-color: var(--color-primary);
  cursor: pointer;
  transition: background-color 0.2s ease, box-shadow 0.2s ease;
}

.google-signin-button:hover {
  background-color: var(--color-primary-dark);
}

.google-signin-button:focus {
  outline: none;
  box-shadow: 0 0 0 2px var(--color-background), 0 0 0 4px var(--color-primary);
}

.google-icon {
  margin-right: var(--space-sm);
  font-weight: bold;
}
</style>

================
File: components/dashboard/Dashboard.vue
================
<template>
  <div class="dashboard-page">
    <div class="dashboard-header">
      <h1>Your Subscription Dashboard</h1>
      <AppButton @click="refreshEmails" :disabled="isLoading">
        <span v-if="isLoading">
          <AppSpinner style="width: 1em; height: 1em; border-width: 2px; margin-right: var(--space-sm);"/> Refreshing...
        </span>
        <span v-else>
          Refresh Emails
        </span>
      </AppButton>
    </div>

    <!-- Sync Status Message -->
    <div v-if="syncStatus" class="sync-status-message" :class="{'success': !syncError, 'error': syncError}">
      {{ syncStatus }}
    </div>

    <!-- Removed initial load spinner - handled by parent index page -->

    <!-- Dashboard Grid -->
    <div class="dashboard-grid">
      <AppCard title="Spending Overview" class="overview-card">
        <!-- TODO: Replace with actual data from composable -->
        <p>Total Monthly Spend: <strong>$XXX.XX</strong></p>
        <p>Total Yearly Spend: <strong>$YYYY.YY</strong></p>
        <div class="placeholder-chart" aria-label="Placeholder for spending chart">Chart Area</div>
      </AppCard>

      <AppCard title="Upcoming Renewals" class="renewals-card">
        <!-- Use subscriptions data from composable -->
        <ul v-if="subscriptions.length">
          <li v-for="sub in subscriptions" :key="sub.id">
             {{ sub.name }} - ${{ sub.cost.toFixed(2) }} - Renews {{ sub.next_renewal }}
          </li>
        </ul>
        <p v-else>No upcoming renewals found.</p>
        <template #footer>
          <NuxtLink to="/subscriptions">View all subscriptions</NuxtLink>
        </template>
      </AppCard>

      <AppCard title="Category Breakdown" class="category-card">
        <!-- TODO: Replace with actual data from composable -->
        <ul>
          <li>Streaming: $XX.XX</li>
          <li>Music: $YY.YY</li>
          <li>Cloud Services: $ZZ.ZZ</li>
        </ul>
         <div class="placeholder-chart small" aria-label="Placeholder for category breakdown chart">Chart Area</div>
      </AppCard>

    </div>

    <!-- Placeholder/Empty state if needed -->
    <!-- <div v-if="!isLoading && !subscriptions.length" class="empty-state"> ... </div> -->

    <!-- Add the Unparsed List component below the grid -->
    <UnparsedList :unparsed="unparsed" />

  </div>
</template>

<script setup>
import { useDashboard } from '@/composables/useDashboard'
import AppButton from '~/components/ui/AppButton.vue'
import AppCard from '~/components/ui/AppCard.vue'
import AppSpinner from '~/components/ui/AppSpinner.vue'
import UnparsedList from '~/components/dashboard/UnparsedList.vue'

// Get state and actions from the composable
const { 
  subscriptions, 
  isLoading, 
  syncStatus, 
  syncError, 
  refreshEmails, 
  unparsed // Add unparsed here
} = useDashboard()

// No need for user check here, parent `pages/index.vue` handles auth wall

</script>

<style scoped>

.dashboard-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: var(--space-xl);
  flex-wrap: wrap;
  gap: var(--space-md);
}

.dashboard-header h1 {
  font-size: var(--font-2xl);
  font-weight: 600;
  margin: 0;
}

.sync-status-message {
  margin-bottom: var(--space-lg);
  padding: var(--space-sm) var(--space-md);
  border-radius: var(--border-radius-sm);
  font-size: var(--font-sm);
  text-align: center;
}

.sync-status-message.success {
  background-color: #dcfce7; /* Example Success */
  border: 1px solid #86efac;
  color: #166534;
}

.sync-status-message.error {
  background-color: #fee2e2; /* Example Error */
  border: 1px solid #fca5a5;
  color: #991b1b;
}


.dashboard-grid {
  display: grid;
  grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
  gap: var(--space-lg);
}

ul {
  list-style: none;
  padding: 0;
  margin: 0;
}

li {
  padding: var(--space-sm) 0;
  border-bottom: 1px solid var(--color-border);
}

li:last-child {
  border-bottom: none;
}

.renewals-card ul,
.category-card ul {
  margin-bottom: var(--space-md);
}

.renewals-card a {
  color: var(--color-accent);
  text-decoration: underline;
  text-underline-offset: 2px;
}

.placeholder-chart {
  height: 150px;
  background-color: #f3f4f6;
  display: flex;
  align-items: center;
  justify-content: center;
  color: var(--color-muted);
  border-radius: var(--border-radius-md);
  margin-top: var(--space-md);
  font-style: italic;
}

.placeholder-chart.small {
    height: 100px;
}

.empty-state {
  text-align: center;
  padding: var(--space-2xl);
  margin-top: var(--space-xl);
  border: 2px dashed var(--color-border);
  border-radius: var(--border-radius-lg);
}

.empty-illustration {
  max-width: 150px;
  margin: 0 auto var(--space-lg);
  opacity: 0.7;
}

.empty-state h2 {
  font-size: var(--font-xl);
  margin-bottom: var(--space-sm);
}

.empty-state p {
  color: var(--color-muted);
  margin-bottom: var(--space-lg);
}
</style>

================
File: components/dashboard/UnparsedList.vue
================
<template>
  <div v-if="unparsed && unparsed.length > 0" class="unparsed-list-container">
    <h2>Unparsed Emails</h2>
    <p>These emails could not be automatically processed:</p>
    <ul>
      <li v-for="(email, index) in unparsed" :key="index">
        <strong>Subject:</strong> {{ email.subject }} <br>
        <strong>Sender:</strong> {{ email.sender }} <br>
        <strong>Date:</strong> {{ formatDate(email.date) }}
        <!-- Add more details or actions if needed -->
      </li>
    </ul>
  </div>
  <div v-else>
    <!-- Optional: Message when there are no unparsed emails -->
    <!-- <p>No unparsed emails found.</p> -->
  </div>
</template>

<script setup lang="ts">
import { defineProps } from 'vue'
import type { GmailSyncResponse } from '@/types/gmailSync'

defineProps<{ unparsed: GmailSyncResponse['unparsed'] }>()

// Basic date formatting, consider using a library like date-fns for robust formatting
const formatDate = (dateString: string) => {
  try {
    return new Date(dateString).toLocaleDateString()
  } catch (e) {
    return dateString // Return original string if parsing fails
  }
}
</script>

<style scoped>
.unparsed-list-container {
  margin-top: 2rem;
  padding: 1rem;
  border: 1px solid #ccc;
  border-radius: 8px;
  background-color: #f9f9f9;
}

h2 {
  margin-bottom: 0.5rem;
}

ul {
  list-style-type: none;
  padding: 0;
}

li {
  margin-bottom: 0.75rem;
  padding: 0.5rem;
  border-bottom: 1px solid #eee;
}

li:last-child {
  border-bottom: none;
}

strong {
  margin-right: 0.5em;
}
</style>

================
File: components/ui/ErrorBanner.vue
================
<template>
  <div
    v-if="message"
    class="error-banner"
    role="alert"
  >
    <strong class="error-title">Error:</strong>
    <span class="error-message">{{ message }}</span>
  </div>
</template>

<script setup>
defineProps({
  message: {
    type: String,
    default: ''
  }
})
</script>

<style scoped>
.error-banner {
  background-color: var(--color-error-bg);
  border: 1px solid var(--color-error-border);
  color: var(--color-error-text);
  padding: var(--space-md) var(--space-lg);
  border-radius: var(--border-radius);
  position: relative;
}

.error-title {
  font-weight: bold;
  margin-right: var(--space-sm);
}

.error-message {
  display: inline-block;
}

/* Example media query if sm:inline behavior was crucial */
/* @media (min-width: 640px) { 
  .error-message {
    display: inline;
  }
} */
</style>

================
File: components/LogoutButton.vue
================
<template>
  <button
    @click="$emit('click')"
    class="logout-button"
  >
    Logout
  </button>
</template>

<script setup>
defineEmits(['click'])
</script>

<style scoped>
.logout-button {
  padding: 0.25rem 0.75rem; /* Approximates px-3 py-1 */
  border: 1px solid var(--color-border); /* Replaces border border-gray-300 */
  font-size: var(--font-sm); /* Replaces text-sm */
  font-weight: 500; /* Replaces font-medium */
  border-radius: var(--border-radius-md); /* Replaces rounded-md */
  color: var(--color-text-secondary); /* Replaces text-gray-700 */
  background-color: var(--color-button-secondary-bg); /* Replaces bg-white */
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.logout-button:hover {
  background-color: var(--color-surface-hover); /* Replaces hover:bg-gray-50 */
}

.logout-button:focus {
  outline: none; /* Replaces focus:outline-none */
  box-shadow: 0 0 0 2px var(--color-background), 0 0 0 4px var(--color-primary); /* Replaces focus:ring-2 focus:ring-offset-2 focus:ring-indigo-500 */
}
</style>

================
File: composables/useDashboard.ts
================
import { ref, watchEffect } from 'vue'
import {
  useSupabaseClient,
  useSupabaseUser,
} from '#imports'
import type { SupabaseClient, PostgrestError } from '@supabase/supabase-js'
import type { GmailSyncResponse } from '@/types/gmailSync'
import { callFunction } from '@/utils/supabaseFunctions'

/* ------------------------------------------------------------------ */
/* local types                                                        */
/* ------------------------------------------------------------------ */

interface Subscription {
  id: string
  user_id: string
  vendor_name: string
  amount: number
  currency: string
  next_renewal_date: string | null
  category?: string | null
  created_at: string
  updated_at: string
}

/* ------------------------------------------------------------------ */
/* composable                                                         */
/* ------------------------------------------------------------------ */

export function useDashboard() {
  const user            = useSupabaseUser()
  const supabase        = useSupabaseClient<SupabaseClient>()

  /* UI state */
  const isLoading       = ref(false)
  const syncStatus      = ref('')
  const syncError       = ref<string | false>(false)
  const needsReGrant    = ref(false)

  /* data */
  const subscriptions   = ref<Subscription[]>([])
  const totals          = ref<{ monthly: number; yearly: number } | null>(null)
  const upcoming        = ref<GmailSyncResponse['upcomingRenewals']>([])
  const categories      = ref<GmailSyncResponse['categoryBreakdown']>([])
  const unparsed        = ref<GmailSyncResponse['unparsed']>([])

  /* --------------------------- helpers --------------------------- */

  async function loadSubscriptions() {
    if (!user.value) return

    const { data, error } = await supabase
      .from('subscriptions')
      .select('*')
      .eq('user_id', user.value.id)
      .order('vendor_name') as {
        data: Subscription[] | null
        error: PostgrestError | null
      }

    if (error) {
      syncError.value  = error.message
      syncStatus.value = 'Error loading subscriptions'
      return
    }

    subscriptions.value = data ?? []
  }

  /* --------------------------- actions --------------------------- */

  async function refreshEmails() {
    if (import.meta.server) return
  
    isLoading.value = true
    syncStatus.value = 'Syncing emails…'
    syncError.value = false
    needsReGrant.value = false
  
    let data
    try {
      data = await callFunction('sync-gmail')
    } catch (err: unknown) {
      let msg = 'unknown_error'
      if (err instanceof Error) {
        msg = err.message
      }
      syncError.value = msg
  
      if (msg === 'revoked_or_expired' || msg === 'no_google_token') {
        needsReGrant.value = true
        syncStatus.value =
          'Google permission revoked or missing — please re‑grant access.'
      } else {
        syncStatus.value = `Sync failed: ${msg}`
      }
  
      isLoading.value = false
      return
    }
  
    totals.value = data.totals
    upcoming.value = data.upcomingRenewals
    categories.value = data.categoryBreakdown
    unparsed.value = data.unparsed
    syncStatus.value =
      `Processed ${data.processed} email${data.processed === 1 ? '' : 's'}` +
      (data.moreAvailable ? ' — click again to fetch more.' : '')
  
    await loadSubscriptions()
    isLoading.value = false
  }
  

  /* ---------------------- auto init / reset ---------------------- */

  watchEffect(() => {
    if (user.value) {
      loadSubscriptions()
    } else {
      subscriptions.value = []
      totals.value        = null
      upcoming.value      = []
      categories.value    = []
      unparsed.value      = []
      syncStatus.value    = ''
      syncError.value     = false
      needsReGrant.value  = false
    }
  })

  return {
    /* state */
    user,
    isLoading,
    syncStatus,
    syncError,
    needsReGrant,
    /* data */
    subscriptions,
    totals,
    upcoming,
    categories,
    unparsed,
    /* actions */
    refreshEmails,
    loadSubscriptions,
  }
}

================
File: middleware/auth.global.ts
================
import { useSupabaseUser, navigateTo } from '#imports'
import { watch } from 'vue'

export default defineNuxtRouteMiddleware(async (to) => {
  // Skip middleware on these pages
  if (to.path === '/login' || to.path === '/auth/callback') {
    return
  }

  const user = useSupabaseUser()

  // If we're on the client and the user state isn't determined yet
  if (import.meta.client && user.value === undefined) {
    await new Promise<void>((resolve) => {
      const unwatch = watch(user, (newUser) => {
        if (newUser !== undefined) {
          unwatch()
          resolve()
        }
      }, { immediate: true })

      // Failsafe timeout
      setTimeout(() => {
        unwatch()
        resolve()
      }, 3000)
    })
  }

  // After user state is resolved, handle navigation
  if (!user.value) {
    return navigateTo('/login')
  }
})

================
File: pages/auth/callback.vue
================
<template>
  <div class="callback-container">
    <!-- 1. still-loading state -->
    <div v-if="loading" class="loading-state">
      <p>Completing sign‑in…</p>
    </div>

    <!-- 2. error state -->
    <div v-else-if="errorMessage" class="error-state">
      <ErrorBanner :message="errorMessage" class="error-banner-spacing" />
      <NuxtLink to="/login" class="retry-link">
        Retry Login
      </NuxtLink>
    </div>

    <!-- 3. success: instant redirect -->
    <div v-else>
      <p>Redirecting…</p>
    </div>
  </div>
</template>

<script setup lang="ts">
import { ref, watchEffect, onMounted } from 'vue'
import { useRoute } from 'vue-router'
import { useSupabaseUser, navigateTo } from '#imports'
import ErrorBanner from '~/components/ui/ErrorBanner.vue'

const route        = useRoute()
const user         = useSupabaseUser()

const loading      = ref(true)
const errorMessage = ref('')

/**
 * 1. If the module put ?error_description=… in the callback URL
 *    surface it and stop loading.
 */
onMounted(() => {
  const err = route.query.error_description as string | undefined
  if (err) {
    errorMessage.value = decodeURIComponent(err.replace(/\+/g, ' '))
    loading.value      = false
  }
})

/**
 * 2. When the automatic PKCE exchange finishes successfully on this /auth/callback route,
 *    `useSupabaseUser()` becomes non‑null → redirect to the actual dashboard at '/'.
 */
watchEffect(async () => {
  // Check for user first
  if (user.value) {
    // User session confirmed, navigate to the main dashboard page
    await navigateTo('/')
    return // Stop further checks in this effect run
  }

  // Handle error from query params (only if no user yet)
  const err = route.query.error_description as string | undefined
  if (err) {
    errorMessage.value = decodeURIComponent(err.replace(/\+/g, ' '))
    loading.value = false
    return // Stop further checks
  }

  // If still no user and no error, remain in loading state.
  loading.value = true
})
</script>

<style scoped>
.callback-container {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 100vh; /* Replaces min-h-screen */
}

.loading-state,
.error-state {
  text-align: center; /* Replaces text-center */
}

.error-banner-spacing {
  margin-bottom: var(--space-lg); /* Replaces mb-4 */
}

.retry-link {
  color: var(--color-primary); /* Replaces text-indigo-600 */
  text-decoration: none;
}

.retry-link:hover {
  color: var(--color-primary-dark); /* Replaces hover:text-indigo-800, assuming a darker primary */
  text-decoration: underline;
}
</style>

================
File: pages/index.vue
================
<template>
  <div>
    <!-- Render Dashboard if user is logged in -->
    <Dashboard v-if="user" />
    <!-- Render LandingHero if user is not logged in -->
    <LandingHero v-else />
  </div>
</template>

<script setup>
import { useSupabaseUser } from '#imports'
// Use Nuxt's auto-import for components unless paths are complex/ambiguous
// import Dashboard from '@/components/dashboard/Dashboard.vue' // Auto-imported usually
// import LandingHero from '@/components/landing/Hero.vue' // Assuming path, adjust if needed

// Define layout (optional, Nuxt might infer 'default')
definePageMeta({
  layout: 'default',
})

// Get the user state
const user = useSupabaseUser()

// No need for login/logout/refresh logic here, it's handled by:
// - useDashboard (refresh)
// - LandingHero (login)
// - LogoutButton in the layout/header (logout)
</script>

<style scoped>
/* Remove all previous scoped styles */
/* Add any page-specific wrapper styles if needed, but likely none required */
</style>

================
File: pages/login.vue
================
<template>
  <div class="login-page">
    <div v-if="user">
      <p>You are already logged in. Redirecting to dashboard...</p>
      <!-- Optional: Add a spinner -->
    </div>
    <div v-else>
      <h1>Login Required</h1>
      <p>You need to sign in to access this application.</p>
      <ErrorBanner :message="errorMessage" class="error-banner-spacing" />
      <GoogleSignInButton @click="handleSignIn" :disabled="loading" />
      <div v-if="loading" class="loading-indicator">
         <AppSpinner /> <!-- Assuming AppSpinner component -->
        <p>Redirecting to Google...</p>
      </div>
    </div>
  </div>
</template>

<script setup>
import { ref, watchEffect } from 'vue'
import { useSupabaseClient, useSupabaseUser } from '#imports'
import { navigateTo } from '#app'
// Assuming components are auto-imported or imported like this:
import GoogleSignInButton from '~/components/auth/GoogleSignInButton.vue'
import ErrorBanner from '~/components/ui/ErrorBanner.vue'
import AppSpinner from '~/components/ui/AppSpinner.vue'

const supabase = useSupabaseClient()
const user = useSupabaseUser()

const loading = ref(false)
const errorMessage = ref('')

// Redirect if user is already logged in
watchEffect(() => {
  if (user.value) {
    navigateTo('/') // Redirect logged-in users to the main page (index/dashboard)
  }
})

async function handleSignIn() {
  loading.value = true
  errorMessage.value = ''
  try {
    const { error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        scopes: 'openid email profile https://www.googleapis.com/auth/gmail.readonly',
        redirectTo: `${window.location.origin}/auth/callback`
      }
    })
    if (error) throw error
    // Redirect happens via Supabase
  } catch (error) {
    console.error('Error signing in from login page:', error)
    errorMessage.value = error.error_description || error.message || 'Login failed.'
    loading.value = false
  }
}

definePageMeta({
  layout: 'minimal' // Use a minimal layout if available, otherwise default
});
</script>

<style scoped>
.login-page {
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  min-height: 80vh; /* Adjust height as needed */
  text-align: center;
  padding: var(--space-lg);
}

.login-page h1 {
  font-size: var(--font-2xl);
  margin-bottom: var(--space-md);
}

.login-page p {
  color: var(--color-muted);
  margin-bottom: var(--space-lg);
}

/* Added styles */
.error-banner-spacing {
  margin-bottom: var(--space-lg); /* Replaces mb-4 */
}

.loading-indicator {
  margin-top: var(--space-lg); /* Replaces mt-4 */
  text-align: center; /* Replaces text-center */
}

/* Assuming GoogleSignInButton might need some margin */
.google-signin-button {
  margin-top: var(--space-md);
}

</style>

================
File: pages/settings.vue
================
<template>
  <div>
    <!-- Use the same header or a dedicated settings layout header -->
    <header class="settings-header">
       <h1 class="settings-title">Settings</h1>
       <!-- Optional: Add navigation back to dashboard or user info -->
       <NuxtLink to="/dashboard" class="back-link">Back to Dashboard</NuxtLink>
    </header>

    <main class="settings-main">
      <!-- Section: Re-Consent Gmail Access -->
      <section class="settings-section">
        <h2 class="section-title">Gmail Access</h2>
        <div v-if="needsReGrant" class="regrant-notice">
          <p>Gmail access scope might be missing or revoked. Grant access to enable email scanning.</p>
          <button
            @click="handleReConsent"
            class="regrant-button"
            :disabled="loadingReconsent"
           >
             {{ loadingReconsent ? 'Processing...' : 'Grant Gmail Access' }}
          </button>
           <p v-if="reconsentError" class="reconsent-error">{{ reconsentError }}</p>
        </div>
        <div v-else>
          <p class="access-granted">Gmail read-only access is currently granted.</p>
          <!-- Optional: Add button to revoke? Requires careful handling -->
        </div>
      </section>

      <!-- Section: Session Info -->
      <section class="settings-section">
        <h2 class="section-title">Session Information</h2>
        <div v-if="sessionInfo">
          <p><strong>User ID:</strong> {{ sessionInfo.user?.id }}</p>
          <p><strong>Email:</strong> {{ sessionInfo.user?.email }}</p>
          <p><strong>Expires At:</strong> {{ sessionInfo.expires_at ? new Date(sessionInfo.expires_at * 1000).toLocaleString() : 'N/A' }}</p>
          <p><strong>Granted Scopes:</strong></p>
          <!-- Displaying scopes requires parsing the access token or having metadata. -->
          <!-- Supabase provider_token doesn't directly expose scopes easily client-side -->
          <ul class="scope-list">
            <li>openid</li>
            <li>email</li>
            <li>profile</li>
            <li :class="['scope-item', { 'scope-granted': hasGmailScope, 'scope-missing': !hasGmailScope }]">
               https://www.googleapis.com/auth/gmail.readonly {{ hasGmailScope ? '(Granted)' : '(Missing/Revoked?)' }}
            </li>
            <!-- Note: This scope list is assumed based on login request -->
          </ul>
        </div>
        <div v-else>
          <p>Loading session information...</p>
        </div>
         <button
            @click="refreshSessionInfo"
            class="refresh-session-button"
            :disabled="loadingSession"
         >
           {{ loadingSession ? 'Refreshing...' : 'Refresh Session' }}
         </button>
      </section>

       <!-- Section: Digest Preferences (Placeholder from prd2.md) -->
       <section class="settings-section">
         <h2 class="section-title">Digest Preferences</h2>
         <p>Configure email digest frequency (Monthly, Weekly, Off).</p>
         <!-- Placeholder for <DigestPrefsForm> -->
         <div class="prefs-placeholder">
           (Digest preference form TBD)
         </div>
       </section>

    </main>
  </div>
</template>

<script setup>
import { ref, onMounted, watchEffect } from 'vue' // Removed unused 'computed'
// import { useSupabaseClient, useSupabaseUser } from '#supabase/client' // Removed - rely on auto-import
import { useRouter } from 'vue-router'
import { useSupabaseClient } from '#imports'

const supabase = useSupabaseClient()
const user = useSupabaseUser()

const sessionInfo = ref(null)
const needsReGrant = ref(false) // Will be updated based on scope check
const hasGmailScope = ref(false) // Derived from session check
const loadingSession = ref(false)
const loadingReconsent = ref(false)
const reconsentError = ref('')

async function fetchSessionData() {
  loadingSession.value = true
  const { data, error } = await supabase.auth.getSession()
  if (error) {
    console.error('Error fetching session:', error)
    sessionInfo.value = { error: error.message }
  } else if (data.session) {
    sessionInfo.value = {
        user: data.session.user,
        expires_at: data.session.expires_at,
        // provider_token: data.session.provider_token, // Use cautiously
        // access_token: data.session.access_token // Use cautiously
    }
    // Placeholder Check for Gmail Scope:
    // This is a simplified check. A robust solution might involve:
    // 1. Decoding the access_token (if JWT) client-side (less secure, exposes token)
    // 2. Calling a secure backend endpoint that verifies the token with Google.
    // 3. Storing granted scopes in user_metadata upon login/refresh via an Edge Function/Hook.
    // Assuming for now: if provider_token exists, scope *might* be okay.
    hasGmailScope.value = !!data.session.provider_token; // VERY BASIC CHECK
    needsReGrant.value = !hasGmailScope.value;

  } else {
     sessionInfo.value = null; // No active session
     needsReGrant.value = true; // Assume regrant needed if no session
     hasGmailScope.value = false;
  }
  loadingSession.value = false
}

function refreshSessionInfo() {
    fetchSessionData();
}

async function handleReConsent() {
  loadingReconsent.value = true
  reconsentError.value = ''
  try {
    // Use the same signInWithOAuth function as the login page
    const { error } = await supabase.auth.signInWithOAuth({
      provider: 'google',
      options: {
        scopes: 'openid email profile https://www.googleapis.com/auth/gmail.readonly',
        // Crucially, Google might automatically skip consent if already granted
        // or prompt only for the missing scope.
        // redirectTo: `${window.location.origin}/settings` // Redirect back to settings?
      }
    })
    if (error) throw error
    // Redirect might happen, or page might reload/re-render. Watch for session changes.
  } catch (error) {
    console.error('Error during re-consent:', error)
    reconsentError.value = error.error_description || error.message || 'Failed to re-grant access.'
  } finally {
      loadingReconsent.value = false
      // Re-fetch session data after attempt
      // Might need a slight delay or rely on auth watcher
      setTimeout(fetchSessionData, 1000);
  }
}

onMounted(() => {
  fetchSessionData()

  // Redirect to login if user is not authenticated
   watchEffect(() => {
       if (!user.value) {
           const router = useRouter()
           router.push('/login')
       }
   })
});

// Optional: Define layout
// definePageMeta({ layout: 'default' });
</script>

<style scoped>
.settings-header {
  display: flex;
  justify-content: space-between; /* Replaces justify-between */
  align-items: center; /* Replaces items-center */
  padding: var(--space-lg); /* Replaces p-4 */
  border-bottom: 1px solid var(--color-border); /* Replaces border-b */
}

.settings-title {
  font-size: var(--font-xl); /* Replaces text-xl */
  font-weight: 600; /* Replaces font-semibold */
}

.back-link {
  color: var(--color-primary); /* Replaces text-indigo-600 */
  text-decoration: none;
}

.back-link:hover {
  color: var(--color-primary-dark); /* Replaces hover:text-indigo-800 */
  text-decoration: underline;
}

.settings-main {
  padding: var(--space-xl); /* Replaces p-6 */
  display: flex;
  flex-direction: column;
  gap: var(--space-xl); /* Replaces space-y-6 */
}

.settings-section {
  padding: var(--space-lg); /* Replaces p-4 */
  border: 1px solid var(--color-border);
  border-radius: var(--border-radius); /* Replaces rounded */
  box-shadow: var(--shadow-sm); /* Replaces shadow */
}

.section-title {
  font-size: var(--font-lg); /* Replaces text-lg */
  font-weight: 500; /* Replaces font-medium */
  margin-bottom: var(--space-md); /* Replaces mb-3 */
}

.regrant-notice {
  background-color: var(--color-warning-bg); /* Replaces bg-yellow-100 */
  border: 1px solid var(--color-warning-border); /* Replaces border-yellow-400 */
  color: var(--color-warning-text); /* Replaces text-yellow-700 */
  padding: var(--space-md) var(--space-lg); /* Replaces px-4 py-3 */
  border-radius: var(--border-radius); /* Replaces rounded */
  position: relative; /* Replaces relative */
  margin-bottom: var(--space-lg); /* Replaces mb-4 */
}

.regrant-button {
  margin-top: var(--space-sm); /* Replaces mt-2 */
  padding: 0.25rem 0.75rem; /* Approximates px-3 py-1 */
  background-color: var(--color-warning); /* Replaces bg-yellow-500 */
  color: var(--color-warning-button-text); /* Replaces text-white */
  border: none;
  border-radius: var(--border-radius); /* Replaces rounded */
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.regrant-button:hover {
  background-color: var(--color-warning-dark); /* Replaces hover:bg-yellow-600 */
}

.regrant-error {
  color: var(--color-error); /* Replaces text-red-600 */
  font-size: var(--font-sm); /* Replaces text-sm */
  margin-top: var(--space-xs); /* Replaces mt-1 */
}

.access-granted {
  color: var(--color-success); /* Replaces text-green-700 */
}

.scope-list {
  list-style: disc; /* Replaces list-disc */
  margin-left: var(--space-lg); /* Replaces ml-4 */
  padding-left: var(--space-md); /* Replaces list-inside - approximates behavior */
  font-size: var(--font-sm); /* Replaces text-sm */
}

.scope-item {
  /* Base style for list items */
}

.scope-granted {
  color: var(--color-success); /* Replaces text-green-700 */
  font-weight: 600; /* Replaces font-semibold */
}

.scope-missing {
  color: var(--color-error); /* Replaces text-red-600 */
}

.refresh-session-button {
  margin-top: var(--space-md); /* Replaces mt-3 */
  padding: 0.25rem 0.75rem; /* Approximates px-3 py-1 */
  border: 1px solid var(--color-border); /* Replaces border border-gray-300 */
  font-size: var(--font-sm); /* Replaces text-sm */
  border-radius: var(--border-radius); /* Replaces rounded */
  cursor: pointer;
  transition: background-color 0.2s ease;
}

.refresh-session-button:hover {
  background-color: var(--color-surface-hover); /* Replaces hover:bg-gray-50 */
}

.prefs-placeholder {
  margin-top: var(--space-sm); /* Replaces mt-2 */
  color: var(--color-muted); /* Replaces text-gray-500 */
}
</style>

================
File: server/tsconfig.json
================
{
  "extends": "../.nuxt/tsconfig.server.json"
}

================
File: supabase/.temp/cli-latest
================
v2.20.12

================
File: supabase/.temp/gotrue-version
================
v2.170.0

================
File: supabase/.temp/pooler-url
================
postgresql://postgres.rntwpgpitdcbzujcrnit:[YOUR-PASSWORD]@aws-0-us-east-2.pooler.supabase.com:6543/postgres

================
File: supabase/.temp/postgres-version
================
15.8.1.070

================
File: supabase/.temp/project-ref
================
rntwpgpitdcbzujcrnit

================
File: supabase/.temp/rest-version
================
v12.2.3

================
File: supabase/.temp/storage-version
================
v1.22.3

================
File: supabase/functions/auth-copy-provider-token/deno.json
================
{
    "imports": {
      "@supabase/supabase-js@2": "https://esm.sh/@supabase/supabase-js@2"
    },
    "compilerOptions": { "lib": ["dom", "deno.ns"] }
  }

================
File: supabase/functions/auth-copy-provider-token/index.ts
================
import { serve } from 'https://deno.land/std@0.192.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

const supabase = createClient(Deno.env.get('SUPABASE_URL')!, Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!)

serve(async (req) => {
  const payload = await req.json()       // comes from GoTrue
  const user    = payload.event.data.new // after_sign_in and after_token_refresh

  const token = user?.provider_token
  if (!token) return new Response('no token', { status: 200 })

  await supabase.from('users').upsert({
    id: user.id,
    provider_token: token,
    needs_regrant: false
  })

  return new Response('ok', { status: 200 })
})

================
File: supabase/functions/sync-gmail/.npmrc
================
# Configuration for private npm package dependencies
# For more information on using private registries with Edge Functions, see:
# https://supabase.com/docs/guides/functions/import-maps#importing-from-private-registries

================
File: supabase/functions/sync-gmail/deno.json
================
{
  "imports": {}
}

================
File: supabase/functions/sync-gmail/index.ts
================
import { serve } from 'https://deno.land/std@0.192.0/http/server.ts'
import { createClient } from 'https://esm.sh/@supabase/supabase-js@2'

/* ────────────────────────────────────────────────────────────── */
/* 0.  Environment variables                                     */
/*     (add SUPABASE_SERVICE_ROLE_KEY in the dashboard if needed)*/
const PROJECT_URL = Deno.env.get('SUPABASE_URL')!
const ANON_KEY    = Deno.env.get('SUPABASE_ANON_KEY')!
const SERVICE_KEY = Deno.env.get('SUPABASE_SERVICE_ROLE_KEY')!
/* ────────────────────────────────────────────────────────────── */

/* temp client – just to verify the incoming JWT                 */
const authClient = createClient(PROJECT_URL, ANON_KEY, {
  auth: { persistSession: false }
})

const CORS = {
  'Access-Control-Allow-Origin': '*',   // change to your prod domain later
  'Access-Control-Allow-Headers':
    'authorization, x-client-info, apikey, content-type, x-provider-token',
}

serve(async (req) => {
  /* pre‑flight -------------------------------------------------- */
  if (req.method === 'OPTIONS') {
    return new Response('ok', {
      headers: { ...CORS, 'Access-Control-Allow-Methods': 'POST, OPTIONS' },
    })
  }

  /* 1.  Validate the JWT that came from the browser ------------- */
  const jwt = (req.headers.get('Authorization') ?? '').replace('Bearer ', '')
  const { data: auth, error: authErr } = await authClient.auth.getUser(jwt)
  if (authErr) {
    return new Response(JSON.stringify({ error: 'unauthorized' }), {
      status: 401,
      headers: CORS,
    })
  }
  const userId = auth.user.id

  /* 2.  Real client – impersonates the user for RLS ------------- */
  const supabase = createClient(PROJECT_URL, SERVICE_KEY, {
    global: { headers: { Authorization: `Bearer ${jwt}` } },
    auth:   { persistSession: false },
  })

  /* 3.  Fetch Google token & watermark ------------------------- */
const { data: userRow } = await supabase
.from('users')
.select('id, email, provider_token, last_internal_date')
.eq('id', userId)
.maybeSingle()                                   // ← null if row missing

const accessToken =
userRow?.provider_token || req.headers.get('x-provider-token')

if (!accessToken) {
return new Response(
  JSON.stringify({ error: 'no_google_token' }),
  { status: 403, headers: CORS },
)
}

/* store token on first run ------------------------------------ */
if (!userRow) {
// first login ➜ create the users row with the required email
const { error: dbErr } = await supabase.from('users').insert({
  id:             userId,
  email:          auth.user.email,               // comes from Supabase Auth
  provider_token: accessToken,
})
if (dbErr) console.error('DB error (users insert)', dbErr)

} else if (!userRow.provider_token) {
// row exists but token was empty ➜ update just that column
const { error: dbErr } = await supabase
  .from('users')
  .update({ provider_token: accessToken })
  .eq('id', userId)
if (dbErr) console.error('DB error (users update)', dbErr)
}


  /* 4.  List & parse e‑mails ------------------------------------ */
  const ninetyDays  = 1000 * 60 * 60 * 24 * 90
  const sinceMs     =
    userRow?.last_internal_date ?? Date.now() - ninetyDays

  const q = `(subscription OR receipt OR invoice OR payment) after:${Math.floor(
    sinceMs / 1000
  )}`
  const listURL =
    `https://gmail.googleapis.com/gmail/v1/users/me/messages?maxResults=200&q=${encodeURIComponent(
      q
    )}`

  const listResp = await fetch(listURL, {
    headers: { Authorization: `Bearer ${accessToken}` },
  })
  if (!listResp.ok) {
    return new Response(
      JSON.stringify({
        error:  'gmail_api_error',
        status: listResp.status,
        detail: await listResp.text(),
      }),
      { status: listResp.status, headers: CORS }
    )
  }

  const listJson = await listResp.json()
  const ids      = (listJson.messages ?? []).map((m: any) => m.id)

  let newest   = sinceMs
  let inserted = 0
  const unparsed: any[] = []

  for (const id of ids) {
    const metaURL =
      `https://gmail.googleapis.com/gmail/v1/users/me/messages/${id}?format=metadata`
    const msg = await (
      await fetch(metaURL, {
        headers: { Authorization: `Bearer ${accessToken}` },
      })
    ).json()

    const headers = Object.fromEntries(
      msg.payload.headers.map((h: any) => [h.name.toLowerCase(), h.value])
    )
    const subject      = headers.subject ?? ''
    const sender       = headers.from ?? ''
    const internalDate = Number(msg.internalDate)
    if (internalDate > newest) newest = internalDate

    const amountMatch = /([$€£]?[\d,.]+)/.exec(subject + ' ' + msg.snippet)
    const vendorMatch = /@([\w.-]+\.\w{2,})/.exec(sender)

    if (amountMatch && vendorMatch) {
      const amount             = Number(amountMatch[1].replace(/[^0-9.]/g, ''))
      const { error: dbErr }   = await supabase.from('subscriptions').insert(
        {
          user_id:    userId,
          vendor_name: vendorMatch[1],
          amount,
          currency:   'USD',
        }
      )
      if (dbErr) console.error('DB error (subscriptions)', dbErr)
      else       inserted += 1
    } else {
      unparsed.push({ subject, sender, date: new Date(internalDate).toISOString() })
      const { error: dbErr } = await supabase.from('unparsed_emails').insert({
        user_id:         userId,
        gmail_message_id: id,
        subject,
        sender,
        message_date:    new Date(internalDate).toISOString(),
        parse_error:     'missing_fields',
      })
      if (dbErr) console.error('DB error (unparsed_emails)', dbErr)
    }
  }

  /* 5.  Update watermark & aggregates --------------------------- */
  await supabase.from('users')
    .update({ last_internal_date: newest })
    .eq('id', userId)

  const { data: totals } = await supabase.rpc('calc_totals', {
    p_user_id: userId,
  })

  return new Response(
    JSON.stringify({
      processed:           ids.length,
      insertedSubscriptions: inserted,
      totals:              totals?.monthly_yearly ?? {},
      upcomingRenewals:    totals?.next_renewals ?? [],
      categoryBreakdown:   totals?.by_category ?? [],
      unparsed,
      moreAvailable:       listJson.resultSizeEstimate > 200,
    }),
    { status: 200, headers: CORS }
  )
})

================
File: supabase/config.toml
================
[functions.sync-gmail]
enabled = true
verify_jwt = true
import_map = "./functions/sync-gmail/deno.json"
# Uncomment to specify a custom file path to the entrypoint.
# Supported file extensions are: .ts, .js, .mjs, .jsx, .tsx
entrypoint = "./functions/sync-gmail/index.ts"
# Specifies static files to be bundled with the function. Supports glob patterns.
# For example, if you want to serve static HTML pages in your function:
# static_files = [ "./functions/sync-gmail/*.html" ]
[functions.auth-copy-provider-token]
# enabled = true            # optional; defaults to true
verify_jwt = false          # hooks already come from Supabase
import_map = "./functions/auth-copy-provider-token/deno.json"  # if you added one
# entrypoint = "./functions/auth-copy-provider-token/index.ts" # only needed if you renamed the file

================
File: types/gmailSync.ts
================
export interface GmailSyncResponse {
  processed: number
  updatedSubscriptions: number
  totals: { monthly: number; yearly: number }
  upcomingRenewals: Array<{
    vendor: string
    amount: number
    due: string // Assuming YYYY-MM-DD format
  }>
  categoryBreakdown: Array<{
    category: string
    total: number
  }>
  unparsed: Array<{
    subject: string
    sender: string
    date: string // Assuming ISO 8601 or similar date string
  }>
  moreAvailable: boolean
}

export interface GmailSyncError {
  error: 'revoked_or_expired'
}

================
File: utils/supabaseFunctions.ts
================
import { useSupabaseClient } from '#imports'

export async function callFunction(
  name: string,
  options?: Record<string, any>
) {
  const supabase = useSupabaseClient()
  const {
    data: { session }
  } = await supabase.auth.getSession()

  if (!session) throw new Error('not_logged_in')

  const headers: Record<string, string> = {
    Authorization: `Bearer ${session.access_token}`
  }
  if (session.provider_token) {
    headers['x-provider-token'] = session.provider_token
  }

  const { data, error } = await supabase.functions.invoke(name, {
    body: options,
    headers
  })

  if (error) {
    const raw = error.context?.responseText
    const parsed = raw ? JSON.parse(raw) : {}
    const code = parsed.error || error.message

    if (code === 'revoked_or_expired' || code === 'no_google_token') {
      const e = new Error(code)
      e.name = 'FunctionError'
      throw e
    }
    throw new Error(`edge_fn_${code}`)
  }

  return data
}

================
File: app.vue
================
<template>
  <div>
    <NuxtLayout>
      <NuxtPage />
    </NuxtLayout>
  </div>
</template>

<style>
</style>

================
File: eslint.config.mjs
================
// @ts-check
import withNuxt from './.nuxt/eslint.config.mjs'

export default withNuxt(
  // Your custom configs here
)

================
File: nuxt.config.ts
================
// https://nuxt.com/docs/api/configuration/nuxt-config
export default defineNuxtConfig({
  compatibilityDate: '2024-11-01',
  devtools: { enabled: true },

  css: [
    '~/assets/css/global.css', 
    '~/assets/css/layout.css',     
  ],
  runtimeConfig: {
    // Private keys are only available on the server
    // supabaseServiceKey: process.env.SUPABASE_SERVICE_KEY,
    // Public keys that are exposed to the client, prefix with 'public'
    public: {
      supabaseUrl: process.env.SUPABASE_URL,
      supabaseKey: process.env.SUPABASE_KEY,
    }
  },

  modules: [
    '@nuxtjs/supabase',
    '@nuxt/eslint',
    '@nuxt/icon',
    '@nuxt/image',
    '@nuxt/scripts'
  ],

  supabase: {
    url: process.env.SUPABASE_URL,
    key: process.env.SUPABASE_KEY,
    clientOptions: {
      auth: {
        flowType: 'pkce',          // generate verifier + challenge
        detectSessionInUrl: true,  // auto‑exchange on first paint
        persistSession: true,
      },
    },
    redirectOptions: {
      login: '/login',
      callback: '/auth/callback',
      exclude: [],
    }
  }
})

================
File: package.json
================
{
  "name": "nuxt-app",
  "private": true,
  "type": "module",
  "scripts": {
    "build": "nuxt build",
    "dev": "nuxt dev",
    "generate": "nuxt generate",
    "preview": "nuxt preview",
    "postinstall": "nuxt prepare"
  },
  "dependencies": {
    "@nuxt/eslint": "^1.3.0",
    "@nuxt/icon": "^1.12.0",
    "@nuxt/image": "^1.10.0",
    "@nuxt/scripts": "^0.11.6",
    "@supabase/supabase-js": "^2.49.4",
    "@unhead/vue": "^2.0.8",
    "eslint": "^9.24.0",
    "nuxt": "^3.16.2",
    "vue": "^3.5.13",
    "vue-router": "^4.5.0"
  },
  "devDependencies": {
    "@nuxtjs/supabase": "^1.5.0"
  }
}

================
File: repomix.config.json
================
{
  "output": {
    "filePath": "repomix-output.txt",
    "style": "plain",
    "parsableStyle": false,
    "fileSummary": true,
    "directoryStructure": true,
    "removeComments": false,
    "removeEmptyLines": false,
    "topFilesLength": 5,
    "showLineNumbers": false,
    "copyToClipboard": false
  },
  "include": [],
  "ignore": {
    "useGitignore": true,
    "useDefaultPatterns": true,
    "customPatterns": []
  },
  "security": {
    "enableSecurityCheck": true
  },
  "tokenCount": {
    "encoding": "o200k_base"
  }
}

================
File: tsconfig.json
================
{
  // https://nuxt.com/docs/guide/concepts/typescript
  "extends": "./.nuxt/tsconfig.json"
}
